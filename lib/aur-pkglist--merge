#!/usr/bin/env perl
use strict;
use warnings;
use v5.20;
my $argv0 = 'pkglist--merge';
my $aur_json;

# Fallback to slower perl-based JSON parsing
if (eval { require JSON::XS; 1 }) {
    $aur_json = JSON::XS->new;
} else {
    require JSON::PP;
    $aur_json = JSON::PP->new;
}

sub parse_json_file {
    my ($path) = @_;

    open my $fh, '<', $path or die "Can't open file: $!";
    my $row = do { local $/; <$fh> };
    close($fh);

    my $obj = $aur_json->incr_parse($row);
    $aur_json->incr_reset();

    return $obj;
}

unless(caller) {
    use Getopt::Long;
    my $opt_pkgname = "";
    my $opt_pkgbase = "";

    GetOptions(
        'n=s' => \$opt_pkgname,
        'b=s' => \$opt_pkgbase
    ) or exit(1);

    if (not length($opt_pkgname)) {
        say STDERR "error: pkgname.json not specified";
        exit(2);
    }
    elsif (not length($opt_pkgbase)) {
        say STDERR "error: pkgbase.json not specified";
        exit(2);
    }

    my $pkgname = parse_json_file($opt_pkgname);
    my $pkgbase = parse_json_file($opt_pkgbase);
    my @merged;

    for my $key (sort keys %{$pkgname}) {
        # Retrieve package information from pkgname.json
        my $pkg = $pkgname->{$key};
        # Append missing fields from pkgbase.json
        my $missing = $pkgbase->{$pkg->{'PackageBase'}};

        for my $key_s (keys %{$missing}) {
            # XXX: compute PopularityUpdated
            $pkg->{$key_s} = $missing->{$key_s};
        }
        push(@merged, $pkg);
    }

    $aur_json->canonical()->pretty();
    say $aur_json->encode(\@merged);
}
